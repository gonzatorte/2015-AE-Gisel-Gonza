ToDo:




Preludio:
	"Sobre lenguaje y biblioteca, hay que presentar argumentos (breves) para fundamentar la elección. La justificación de utilizar AE surge de los conceptos vistos en el teórico."


Cosas:
	Guardar soluciones no factibles como alelo no dominante en un organismo diploide.
	Para truchar la candiad de generaciones propongo codificar varias islas en 1 sola población (organismo n-ploide?)
	Densidad de grafos (cantidad de vecinos)


Problema 1: Mochila con repeticiones sin pesos
	1. Codificación:
		1. Codificaciones no factibles.
	2. Población inicial.
	3. Funcion de fitness.
	4. Seleccción:
		Remplazo.
	5. Cruzamiento.
	6. Mutación.
	7. Remplazo.


Codificación:
	Podemos tomar 2 rep
		1. La mochila:
			La que dijo Gise, un arreglo donde cada valor.
		2. La de contadores de tipo:
			Representación de 

			Al aplicar el cruzamiento en la anterior representación, se tiene un comportamiento más discruptivo donde ademas se benefician al best fit (los valores pequeños tienen tanto peso como los grandes).
			Sobre esta representación, el cruzamiento SPX o del estilo van a ser menos disruptivos que en el caso anterior.
			Por lo tanto, no etoy seguro cual es mejor para etapas avanzadas.
		
		Vamos a intentar combinar ambas representaciones, a aplicarse en distintos estadios de la evolución (tardia vs temprana). Esto plantea problemas en la funcion de fitness a aplicar entre ambas representaciones, pero podemos elegir una función de fitness compatibles (de hecho es la misma conceptualmente al problema) si desearamos hacerlo.

		Vamos a diferenciar las etapas:
			Por la variación de la desviación media. (no lo creemos beno pues es multimodal)
			Por la diferencia de fitness entre soluciones consecutivas. (Parece mas adecuada)

Fitness
	Podemos elegir dos funciones de fitness posibles:
		Xi es la cantidad de aperitivos tipo i
		Ci es el costo del aperitivo tipo i (peso)
		O es el costo objetivo

		Intentamos en más minimizar la distancia del valor objetivo.
			v = |Sum(Ci*Xi) - O|
		Como los algoritmos evolutivos intentan maximizar, debemos transformar la funcion anterior para transformar el problema en uno de maximización.

			Discutimos dos posibles transformaciones:
				Aquella que suege de una cota de peor caso:
					F = CostoPeorCaso - v
					CostoPeorCaso = sum(Teniendo el maximo de la rep de contador de tipo)

			Otra que surge de la suma del costo:
				F = 1/(v + 1)

		Tomaremos la segunda por ser compatible con ambas representaciones.


Selecciones:
	Solo los más aptos se pueden reproducir.
	Ajustamos esta funcion de fitness para que tenga valores positivos y podamos aplicar seleccion proporcional de manera correcta.
		proporción de selección
		pj = Fj/Sum(Fi)


Cruzamiento:
	Debemos elegir cuantos padres elegimos para cruzar.
		Vamos a cruzar a todos los seleccionados con todos, pues es justo y no requiere más decisiones ni politicas de selección (es simetrico el relacionamiento de los padres).
	Como no existe dependencia espacial entre los distintos locus de los genes podemos usar cruzamiento uniforme.
	Vamos a exegir, sin que deje de aplicarse lo anterior, que los genes se ubiquen ordenadamente en función de su costo, intentando optimizar la siguiente politica greedy dada por la heuristica siguiente: 
		Heuristicas Extra:
			La de la solución de la mochila fraccionaria.

Mutación:
	mutación uniforme sobre los valores posibles de alelo de cada gen.
	Mi = techo(N/Ci)
	Bi = (Bi + rand(0,Mi)) % Mi

Remplazo:
	Vamos a usar un modelo generacional, por lo tanto, cada 2 padres obtendremos 2 hijos y vamos a generar tanto hijos como sea necesario para obtener una población de igual tamaño.

	Otra idea:
		Con los nuevos hijos querremos substituir a los padres por completo, por lo tanto tenemos que elegir en el proceso de selección n padres de la población tamaño M, dando n*(n-1)/2 hijos, donde debe ser n*(n-1)/2 = M. Ajustar los parámetros de modo de cumplir la anterior equación.


Condición de parada:
	Cuando fitness llegue a 0 o se dan muchas iteraciones.

__________________________________________________________



Problema 2: Mochila sin repetidos con pesos

	1. Codificación:
		Array de 0 o 1 de largo la cantidad de elementos. Puede entenderse tanto como una representación de enteros como en binario.
		El arreglo está ordenado por peso.
		La idea va a ser que el cruzamiento intente resolver el problema entero de entrar en la mochila.
		En principio las soluciones no factibles (que no cumplen la desigualdad) se van a permitir en las generaciones, para mantener los genes que permiten aproximarse a la función por arriba de la restricción de peso, pero se van a penalizar en el fitness.

	2. Población inicial.

	3. Funcion de fitness.
		Va a ser dada por partes según requiera penalización o no:
			Si se está por debajo del peso de la restricción, la función de fitness será solo la ganancia total.
			Si está por encima, va a ser la ganancia total penalizada por la ganancia de la diferencia de peso (tomada en promedio).
				Gtot-((2*Gtot*(k-p))/k)
		Quizas más adelante haga falta tantear con un peso en la función de fitness para ajustarnos a los parámetros de ejecución, que no será otra cosa que una función de escalado lineal.

	4. Seleccción:
		Remplazo.

	5. Cruzamiento.
		SPX. Idema anterior.

	6. Mutación.
		Mutación de bit aleatorio.

	7. Remplazo.
		Idem caso anterior.

	Condición de parada:
		Cuando fitness se den muchas iteraciones. No conocemos el óptimo del problema a priori, nos basta con tener una buena solución.


Puntos a tocar en el informe:
	¿Qué biblioteca fue utilizada?
		Malva para el de aperitivos, nos pareció bastante desprolijo, aunque quizás 
	¿Qué representación fue utilizada para las soluciones candidatas?
	¿Qué estrategia fue utilizada para inicializar la población?
	¿Qué operadores evolutivos fueron utilizados?
	¿Cómo fue definida la función de fitness?
	Para el ejercicio 1:
		¿Cúal fue la solución encontrada?
		¿Se encontró más de	una solución?
	Para el ejercicio 2:
		¿Qué estrategia fue utilizada para el manejo de soluciones no factibles?


ToDo Implementación:
	Malva (aperitivos):
		*Ver como se configura la selección en malva (ruleta? o proporcional).
		*Ver video presentacion malva a ver que son los parametros de selección.
			Creo que es torneo = 1, en ese caso ruleta es 2.
		*Sorting
		*Hacer un algoritmo de fuerza bruta para hallar mejor solución en casos pequeños.
			*Para tratar de responder si existe solucion y si hay mas de una.

	*Whatchmacker:
		Gisel:
			*Pasaje por parámetro del archivo. (Gisel).
			*Escribir a un archivo. (Gisel).
			*Hacer casos de pruebas mas triviales y guardarlos en instancias de .in (cuanto debe dar que se escriba en la última linea del .in ).
			*Instalate netbeans en windows para no estar tan lenta.
			*Ponerle otros nombres a las clases (mas similares a los del teórico)

		Gonza:
			*Script de ejecución.
			*Como asegurar que siempre tenga alguna solución factible?
				*Ver como obtener la ultima generaciones en vez del mejor.
			*Probar variando los parametros (cantidad de población, mutación, escalara la función de fitness, velocidad de convergencia).
			*Explicar pq estamos usando elitismo (remplazo).
			*Falta Sorting y deco y enco en lectura/escritura.
			*Hacer un algoritmo de fuerza bruta para hallar mejor solución en casos pequeños.
				Para tratar de responder si existe solucion y si hay mas de una.
			*Bajar javadocs de watchmaker.
			*Graficar fitness vs .
			*Pensar en la distancia del espacio de busqueda.
			*Agregar los compilados y temporales al .gitignore
				.o .exe .log .in .ttt .aux .lof .lot .fff
				brute_force generator
